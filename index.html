<html>
<head>
	<title>Sub-C Adventure</title>
	<link rel="stylesheet" type="text/css" href="reset-min.css">
	<style type="text/css" media="screen">
	html, body {
		background: #000000;
	}
	
	* {
		image-rendering: -moz-crisp-edges;
	}
	
	@font-face {
		font-family: Press Start K;
		src: url("res/prstartk.ttf");
	}
	</style>
</head>
<body>
<div id="main"></div>
</body>
<script type="text/javascript" src="bdge/engine.js"></script>
<script type="text/javascript" src="jquery-min.js"></script>
<script type="text/javascript">
var waveDelay = 0;
var curPhase = 0;
var curWave = null;
var waves = [];

$(document).ready(function() {
	engine.init("main", 256, 240, 2);
	
	engine.title = "Sub-C Adventure";
	engine.showFps = true;
	
	bdge.input.map("up", bdge.input.UP);
	bdge.input.map("down", bdge.input.DOWN);
	bdge.input.map("left", bdge.input.LEFT);
	bdge.input.map("right", bdge.input.RIGHT);
	bdge.input.map("d", bdge.input.D);
	bdge.input.map("f", bdge.input.F);
	
	bdge.loader.registerResource("tiles", "res/tiles.png", "image");
	bdge.loader.registerResource("shot", "res/shot.png", "image");
	bdge.loader.registerResource("ship", "res/ship.png", "image");
	bdge.loader.registerResource("slug", "res/slug.png", "image");
	
	engine.setSplashImage("res/splash.png");
	
	engine.gameInit(function() {
		engine.createObjClass("bgClass", {
			y: -240,
			z: -1,
			process: function() {
				this.y++;
				if (this.y >= 0) this.y = -240;
			},
			draw: function(ctx) {
				engine.drawTileMap(this.map, bdge.loader.get("tiles"), this.x, this.y, 16, 30, 16, 16);
			},
			map: [
				[4,4,3,2,0,0,0,0,0,0,0,0,0,3,4,4],
				[4,3,0,0,0,0,0,0,0,0,0,1,0,0,3,4],
				[4,3,0,0,0,0,0,0,0,0,0,0,0,0,4,4],
				[4,0,0,0,2,0,0,0,0,0,0,2,0,2,4,4],
				[4,4,4,1,0,0,0,0,0,0,0,0,0,0,3,4],
				[4,4,4,4,0,0,0,0,0,0,0,0,0,1,3,4],
				[4,3,4,3,0,0,0,0,0,0,0,0,0,4,4,4],
				[4,3,3,3,0,1,0,0,0,1,0,1,4,4,4,4],
				[4,0,3,0,0,0,0,0,0,0,0,0,4,4,4,4],
				[4,2,0,0,0,0,0,0,0,0,0,0,3,4,4,4],
				[4,0,1,0,0,0,0,0,0,0,0,0,3,3,4,4],
				[4,4,4,0,0,0,0,0,0,2,0,0,0,3,3,4],
				[4,4,4,0,0,0,0,0,0,0,0,0,1,4,3,4],
				[4,4,4,0,0,0,2,0,0,0,0,0,0,4,4,4],
				[4,4,3,0,1,0,0,0,0,0,0,0,2,3,4,4],
				[4,4,3,2,0,0,0,0,0,0,0,0,0,3,4,4],
				[4,3,0,0,0,0,0,0,0,0,0,1,0,0,3,4],
				[4,3,0,0,0,0,0,0,0,0,0,0,0,0,4,4],
				[4,0,0,0,2,0,0,0,0,0,0,2,0,2,4,4],
				[4,4,4,1,0,0,0,0,0,0,0,0,0,0,3,4],
				[4,4,4,4,0,0,0,0,0,0,0,0,0,1,3,4],
				[4,3,4,3,0,0,0,0,0,0,0,0,0,4,4,4],
				[4,3,3,3,0,1,0,0,0,1,0,1,4,4,4,4],
				[4,0,3,0,0,0,0,0,0,0,0,0,4,4,4,4],
				[4,2,0,0,0,0,0,0,0,0,0,0,3,4,4,4],
				[4,0,1,0,0,0,0,0,0,0,0,0,3,3,4,4],
				[4,4,4,0,0,0,0,0,0,2,0,0,0,3,3,4],
				[4,4,4,0,0,0,0,0,0,0,0,0,1,4,3,4],
				[4,4,4,0,0,0,2,0,0,0,0,0,0,4,4,4],
				[4,4,3,0,1,0,0,0,0,0,0,0,2,3,4,4],
			],
		});
		engine.createObj("bgClass", "bg");
		
		engine.createObjClass("shotClass", {
			group: "shots",
			z: 99,
			width: 4,
			height: 8,
			process: function() {
				var oldY = this.y;
				this.y -= 8;
				
				// Shot check
				var shot = this;
				bdge.util.forEach(engine.groups["enemy"], function(enemyId, enemy) {
					if (engine.boxCollide(shot.x, shot.y, shot.width, shot.height + (oldY - shot.y), enemy.x, enemy.y, enemy.width, enemy.height)) {
						engine.destroyObj(enemyId);
						engine.destroyObj(shot.id);
						return;
					}
				});
				
				if (!engine.inView(this.x, this.y, this.graphic.fWidth, this.graphic.fHeight)) {
					engine.destroyObj(this.id);
				}
			},
			graphic: {
				img: "shot",
				fWidth: 4,
				fHeight: 8,
			},
		});
		
		engine.createObjClass("pcClass", {
			x: 120,
			y: 192,
			z: 100,
			shotDown: false,
			process: function() {
				if (bdge.input.keys["up"]) this.y -= 2;
				if (bdge.input.keys["down"]) this.y += 2;
				if (bdge.input.keys["left"]) this.x -= 3;
				if (bdge.input.keys["right"]) this.x += 3;
				
				if (bdge.input.keys["d"]) {
					if (!this.shotDown) {
						var shot = engine.createObj("shotClass");
						shot.x = this.x + 6;
						shot.y = this.y + 4;
						this.shotDown = true;
					}
				} else {
					this.shotDown = false;
				}
			},
			graphic: {
				img: "ship",
				fWidth: 16,
				fHeight: 16,
				anim: true,
				delay: 15,
				frameCount: 2,
			},
		});
		engine.createObj("pcClass", "pc");
		
		engine.createObjClass("slugClass", {
			z: 90,
			width: 16,
			height: 16,
			group: "enemy",
			process: function() {
				this.y += 1;
				
				if (!engine.inView(this.x, this.y, this.graphic.fWidth, this.graphic.fHeight)) {
					engine.destroyObj(this.id);
				}
			},
			parentWave: null,
			onDestroy: function() {
				if (this.parentWave != null) this.parentWave.enemyDead();
			},
			graphic: {
				img: "slug",
				fWidth: 16,
				fHeight: 16,
				anim: true,
				delay: 10,
				frameCount: 2,
			},
		});
		
		// Spawns 10 slugs every 32 frames and waits for them to be gone
		var slugWave = new EnemyWave({
			phaseCount: 10,
			delay: 32,
			enemyCount: 10,
			action: function(phase) {
				var slug = engine.createObj("slugClass");
				slug.y = -12;
				slug.x = bdge.util.rand(3, 14) * 16;
				slug.hflip = bdge.util.rand(0, 100) > 50;
				slug.parentWave = this;
			}
		});
		
		waves.push(slugWave);
		
		var drawScore = function () {
			engine.drawRect(0, 0, 256, 16);
			engine.drawText("SCORE:", 8, 4);
		};
		
		/**
		 * Waves work in phases. Each phase lasts a certain amount of time,
		 * and when they're all done, we wait for the wave to be marked as
		 * over, and move onto the next wave. 
		 *
		 * A phase typically corresponds to spawning a single enemy at a set
		 * delay. 
		 */
		engine.setProcess(function() {
			// Grab the next wave if the current wave is done. 
			// If there are no more waves, game over!
			if (curWave == null) {
				curWave = waves.shift();
				
				if (typeof curWave == "undefined") {
					engine.setDraw(function() {
						drawScore();
						
						engine.drawRect(88, 112, 80, 16);
						engine.drawText("GAME OVER", 92, 116);
					});
					engine.setProcess(function() {});
					return;
				} else {
					curPhase = 0;
					waveDelay = curWave.delay;
				}
			}
			
			// If the phases are done, wait until the wave ends and kill it
			// Otherwise, continue the current phase or move to the next one.
			if (curWave.phaseCount <= curPhase) {
				if (curWave.waveDone) curWave = null;
			} else if (waveDelay >= curWave.delay) {
				curWave.action(curPhase);
				curPhase++;
				waveDelay = 0;
			} else {
				waveDelay++;
			}
		});
		
		engine.setDraw(function() {
			drawScore();
		});
		
		engine.globalFont = "8px Press Start K";
		engine.globalFontFill = "#FFFFFF";
	});
	
	engine.start(30);
});

/**
 * An EnemyWave, as the name suggests, defines a preset wave of enemies.
 */
var EnemyWave = function(props) {
	this.phaseCount = props.phaseCount;
	this.delay = props.delay;
	this.action = props.action;
	this.waveDone = false;
	
	if (typeof props.enemyCount != "undefined") {
		this.enemyCount = props.enemyCount;
		this.enemyDead = function() {
			this.enemyCount--;
			if (this.enemyCount <= 0) this.waveDone = true;
		};
	}
};
</script>
</html>
