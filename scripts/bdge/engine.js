/* * Badly Designed Game Engine * Copyright (c) 2010, Michael Kelly <Osmose1000@gmail.com> *  * Permission to use, copy, modify, and/or distribute this software for any * purpose with or without fee is hereby granted, provided that the above * copyright notice and this permission notice appear in all copies. *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. *//** * Handles the main game loop, drawing, and interaction between objects. */define(["require", "exports", "module",    "./input",    "./loader",    "./util"],function(require, exports, module,    input,    loader,    util) {var engine = exports; // Helps make code clearer// Engine settings and defaultsexports.fps = 30;exports.msPerFrame = 0;exports.showDebugInfo = false;exports.title = "BDGE Game Engine"; // Window title// Canvas size and scalingexports.width = 256;exports.height = 240;exports.scaledWidth = 256;exports.scaledHeight = 240;exports.scale = 1;exports.buffer = null;exports.bufferCtx = null;exports.canvas = null;exports.canvasCtx = null;// Camera determines the region of the world being displayed// Width and height are redundant here since the canvas already has thatexports.camera = {    x: 0,    y: 0};// Drawing defaultsexports.bgColor = "#000000";exports.font = "8px Arial";exports.fontFill = "#000000";exports.splashImageUrl = null;// Object organizationexports.entities = {};  // Entity, indexed by entityIdexports.groups = {};    // Groups; index is groupId, value is an object                        // containing entities, indexed by entityId// zOrderEntities contains all entities ordered by their z value for drawingexports.zOrderEntities = new util.SortedArray(function (a, b) {    return a.z - b.z;});// Frameskip timing and tracking infoexports.frameskip = 0;exports.drawFrames = 0;exports.processFrames = 0;exports.timing = {    lowidle: 0,    hiidle: 5,    minfs: 0,    maxfs: 5}; var ctx; // Saves typing this.bufferCtx all the time/** * Initializes the engine. This shouldn't be called until the width, height, * scale, and FPS have been set for the engine. */exports.init = function(containerId) {    // Set some convenient variables to have    this.scaledWidth = this.width * this.scale;    this.scaledHeight = this.height * this.scale;    this.msPerFrame = 1000 / this.fps;        // Init buffer and visible canvas    this.buffer = document.createElement("canvas");    this.buffer.setAttribute('height', this.height);    this.buffer.setAttribute('width', this.width);    this.bufferCtx = this.buffer.getContext("2d");    ctx = this.bufferCtx;        this.canvas = document.createElement("canvas");    this.canvas.setAttribute('height', this.height);    this.canvas.setAttribute('width', this.width);    this.canvasCtx = this.canvas.getContext("2d");        // Set CSS dimensions to scale    this.canvas.style.width = this.scaledWidth + "px";    this.canvas.style.height = this.scaledHeight + "px";        var container = document.getElementById(containerId);        // Bind keyboard events    container.onkeydown = input.onkeydown;    container.onkeyup = input.onkeyup;        // Add the canvas to the page    container.appendChild(this.canvas);  };/** * Starts the game loop */exports.start = function() {    // load() starts loading resources and begins the game loop when loading    // is finished    var load = function(img) {        loader.load();        util.wait(function() {            return loader.loadingComplete;        }, function() {            engine.cycle();        });    };        // Draw a splash image if we have one, and then start loading    if (this.splashImageUrl != null) {        var img = new Image();        img.onload = function() {            ctx.drawImage(img,                 0, 0, engine.width, engine.height,                 0, 0, engine.width, engine.height            );            load();        };        img.src = this.splashImageUrl;    } else {        load();    }};/** * Main event loop of the engine.  */var frameStart = 0, fskid = 0;exports.cycle = function() {    frameStart = (new Date()).getTime();        // Perform game logic    this.process();    this.processFrames++;        // Draw if we can afford it    if (fskid >= this.frameskip) {        this.draw();        this.drawFrames++;        fskid = 0;    } else {        fskid++;    }        // Display FPS    if (this.showDebugInfo) {        this.monitorFPS();    }        // Timing scheme adapted from Akihabara :D    // Set frameStart to when the next frame SHOULD'VE started    frameStart = this.msPerFrame - ((new Date()).getTime() - frameStart);        // Adjust frameskip if we're moving too slow or too quickly    if (frameStart < this.timing.lowidle &&         this.frameskip < this.timing.maxfs) {        this.frameskip++;    }    if (frameStart > this.timing.hiidle &&         this.frameskip > this.timing.minfs) {        this.frameskip--;    }        // Wait (or not if we can't afford it)    setTimeout(this.cycleCallback, (frameStart <= 0 ? 1 : frameStart));};   // Bind the function to be able to use it as a callback/** * Callback that calls cycle. Used until Function.prototype.bind works */exports.cycleCallback = function() {    engine.cycle();};/** * Updates the window title with the FPS */var fpsMonitorDelay = 0;exports.monitorFPS = function() {    if ((new Date()).getTime() - fpsMonitorDelay > 1000) {        document.title = this.title + "(Proc:" + this.processFrames + ",Draw:"             + this.drawFrames + ")";        this.drawFrames = 0;        this.processFrames = 0;        fpsMonitorDelay = (new Date()).getTime();    }};/** * Sets a custom process function called after objects are processed */var customProcess;exports.setCustomProcess = function(func) {    customProcess = func;};/** * Sets a custom draw function that is called after objects are drawn. * * The function is passed the buffer context when called for convenience */var customDraw;exports.setCustomDraw = function(func) {    customDraw = func;};/** * Calls the process function of every object and handles their animations */exports.process = function() {    var g;    this.zOrderEntities.iter(function(index, obj) {        g = obj.graphic;        if (g.anim) {            if (g.framesSinceLast >= g.delay) {                g.framesSinceLast = 0;                g.curFrame = (g.curFrame + 1) % g.frameCount;            } else {                g.framesSinceLast++;            }        }                obj.process();    });        if (typeof customProcess == "function") customProcess();};/** * Draws objects to the buffer, then draw the buffer to the screen */exports.draw = function() {    // Clear background    ctx.save();    ctx.fillStyle = this.bgColor;    ctx.fillRect(0, 0, this.width, this.height);    ctx.restore();        // Draw objects    this.zOrderEntities.iter(function(index, obj) {        obj.draw(ctx);    });        // Custom drawing    if (typeof customDraw == "function") customDraw(ctx);        // Draw buffer to screen    this.canvasCtx.drawImage(this.buffer, 0, 0);};/** * Adds an entity to the game. Any entity passed into this MUST have been * created by a class descended from the Entity class. */var lastObjId = 0;exports.addEntity = function(entity, id) {    // Assign unique id; generate one if it is not provided    if (typeof id == "undefined") {        id = lastObjId++;    }    entity.id = id;        // Create group if it doesn't exist    if (typeof this.groups[entity.group] == "undefined") {        this.groups[entity.group] = {};    }        // Add to entity collections    this.groups[entity.group][id] = entity;    this.entities[id] = entity;    this.zOrderEntities.add(entity);};/** * Deletes all references within the engine to the entity. */exports.removeEntity = function(id) {    var entity = this.entities[id];        // We'll cut some slack if you're trying to remove something that doesn't    // exist.    if (typeof entity != "undefined") {        delete this.entities[id];        delete this.groups[entity.group][id];        this.zOrderEntities.removeItem(entity, function(a, b) {            return (a.id == b.id ? 0 : -1);        });                // Run the onremove handler if it exists        if (typeof entity.onRemove == "function") {            entity.onRemove();        }    }};/** * Shorthand for checking if two entities collide */exports.entityCollide = function(e1, e2) {    return util.boxCollide(        e1.x, e1.y, e1.width, e1.height,        e2.x, e2.y, e2.width, e2.height    );};/** * Returns true if the given box is within the view of the camera, false  * otherwise */exports.inView = function(x, y, width, height) {    return util.boxCollide(            x, y, width, height,             this.camera.x, this.camera.y, this.width, this.height    );};/** * Base class for game entities. * * Use an instance of this class as the prototype for any entities you wish to * use in the game. */var Entity = function() {    this.x = 0;    this.y = 0;    this.z = 0;    this.width = 0;    this.height = 0;    this.group = "";        this.graphic = {        img: null,        vflip: false,        hflip: false,        anim: false,        curFrame: 0,        frameCount: 0,        fWidth: 0,        fHeight: 0,        delay: 0,   // NOTE: Delay is in frames, not seconds        framesSinceLast: 0    };};Entity.prototype.inView = function() {    var g = this.graphic;    return engine.inView(this.x, this.y, g.fWidth, g.fHeight);};Entity.prototype.process = function() {};Entity.prototype.draw = function(ctx) {    var g = this.graphic;    var img = loader.getData(g.img);    if (img != null && engine.inView(this.x, this.y, g.fWidth, g.fHeight)) {        ctx.save();                ctx.translate((g.hflip ? g.fWidth : 0), (g.vflip ? g.fHeight : 0));        ctx.scale((g.hflip ? -1 : 1), (g.vflip ? -1 : 1));                var dx = (this.x - engine.camera.x) * (g.hflip ? -1 : 1);        var dy = (this.y - engine.camera.y) * (g.vflip ? -1 : 1);                ctx.drawImage(img,             g.curFrame * g.fWidth, 0, g.fWidth, g.fHeight,            dx, dy, g.fWidth, g.fHeight        );        ctx.restore();    }};// Expose Entityexports.Entity = Entity;});